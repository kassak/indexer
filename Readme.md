# Описание
Библиотека indexer представляет собой сервис для фонового
индексирования файлов, для дальнейшего поиска. Ее внешний
интерфейсом является класс *Indexer*, на конструктор которому
передаются: фабрика классов, выполняющих разделение файлов
на слова, и размеры внутренних очередей, количество потоков
разбора файлов. После создания класса необходимо запустить
сервис методом *startService()* (методом *stopService()* его
можно остановить). Далее можно пользоваться методами класс:
 - *add()* асинхронная регистрация папки/файла;
 - *remove()* асинхронная дерегистрация папки/файла;
 - *search()* получение списка файлов и их актуальность по слову;
 - *getFiles()* получение списка всех файлов в индексе + доп.информация;
 - *getWords()* получение списка всех слов в индексе;
 - *getStats()* статистики по индексу.

# Архитектура

## Indexer
Сервис *Indexer* скрывает от пользователя внутреннюю структуру
библиотеки. Внутри себя он запускает сервисы *IndexManagerService*
и *FSWatcherService*.

## FSWatcherService
Сервис *FSWatcherService* запускает внутри себя *FSEventsService*,
а сам запускает поток, в котором обрабатывает запросы пользователя на
добавление/удаление папок/файлов. Асинхронная обработка этих запросов
необходима, чтобы не блокировать пользовательский поток при обработке
директорий с большим числом файлов. Также в этом потоке обрабатываются события
от *FSEventsService* и передаются сервису *IndexManagerService* через
интерфейс *IFSEventsProcessor*.

## FSEventsService
Сервис *FSEventsService* в своем потоке слушает события файловой системы.
События сообщаются сервису *FSWatcherService* через интерфейс *IRawFSEventsProcessor*.

## IndexManagerService
Сервис *IndexManagerService* запускает внутри себя сервис *FilesProcessorService*,
а сам запускает поток, в котором занимается поддержанием индекса в актуальном
состоянии. Реализует интерфейс *IFSEventsProcessor* для получения уведомлений
о событиях файловой системы от сервиса *FSEventsService*, *IFileProcessingResults*
для получения результатов обработки файлов от сервиса *FilesProcessorService* и
интерфейс *IFilesProcessor* для получения команд на обработку файлов от класса
*IndexProcessor*. События файловой системы и результаты обработки файлов
складываются в очередь, которую обрабатывает поток. Таким образом, модификация
индекса происходит только в этом потоке, что позволяет уменьшить число блокировок
и упростить модификацию индекса. Обработка индекса делегируется классу *IndexProcessor*.

## IndexProcessor
Хранит внутри себя индекс *IndexStorage* и обрабатывает запросы на его
актуализацию и получение данных. Модификация данных происходит из одного потока.
Запросы на обработку файлов передаются сервису *IndexManagerService* через
интерфейс *IFilesProcessor*.

## IndexStorage
Хранит в себе файлы с информаций об их статусе, слова и двунаправленные
связи между ними. Гарантированно Single-Writer Multiple-Reader.

## FilesProcessorService
Занимается обработкой файлов. Содержит в себе пул потоков, обрабатывающих
запросы на разбиение файлов, полученных через интерфейс *IFilesProcessor*. Добавление
файла в очередь не блокирующее. Результаты разбора идут в *IndexManagerService* через
интерфейс *IFileProcessingResults*.

## Потоки
Пользовательский поток блокируется только при заполнении очереди на добавление
(хотя можно сделать возможность отказа). Потоки *FSWatcherService* и *FSEventsService*
могут производить большой объем данных, поэтому в случае заполнения очереди
*IndexManagerService*, эти потоки блокируются на отправке новых сообщений,
пока другие части системы не справятся со своей работой. Поток *IndexManagerService*
почти никогда не блокируется - он потребляет и перераспределяет почти все сообщения.
Потоки *FilesProcessorService* блокируются, если результат разбора файлов не
успевает обрабатываться. Сообщения этих потоков обрабатываются приоритетно.

## Хранение индекса
Первой идеей было хранение индекса в боре, что позволило бы сократить объем памяти,
занимаемый словами. Но мне не удалось найти реализацию бора, которая бы позволила
бы при вставке слова получить на него *handle*, по которому его можно было бы удалить.
Без такой возможности для удаления слова из бора, требуется само слово, которое нужно
хранить, следовательно, наличие бора бессмысленно. Свой бор я реализовывать не стал.
Сейчас индекс реализован в виде двух перекрестно ссылающихся *Map*'ов.

# Сборка и тестирование
Все дальнейшие операции можно проделать из IDEA, просто имспортировав проект.

## Сборка
Сборка осуществляется с помощью Gradle:
```sh
sh ./gradlew fatJar
```
или
```cmd
gradlew.bat fatJar
```
Возможно будет необходимо прописать переменную окружения *JAVA_HOME*.
Результатом будет *indexer-all-1.0.jar* в директории *./build/libs*.

## Запуск юнит-тестов
Юнит тесты используют JUnit. Запуск через Gradle:
```sh
sh ./gradlew test
```
или
```cmd
gradlew.bat test
```
Результаты тестирования можно подробно изучить в *./build/reports/tests*.

## Запуск тестового приложения
Тестовое приложение встроено в jar библиотеки. В качестве аргумента командной
строки приложение принимает путь к файлу с настройками. В нем указано:
 - *tokenizerFactoryClass* класс фабрики парсеров;
 - *parserThreadsNum* количество потоков, разбирающих файлы;
 - *parserQueueSize* размер очереди *FilesProcessorService*;
 - *registrationQueueSize* размер очереди *FSWatcherService*;
 - *internalQueueSize* ограничения на очереди *IndexManagerService*.

К приложению прилагаются два файла настроек:
 - *config1.properties* разделителем слов считаются символы, не являющиеся буквами или цифрами;
 - *config2.properties* разделителем слов считаются пробельные символы.

Запуск осуществляется:
```sh
java -jar ./build/libs/indexer-all-1.0.jar ./config1.properties
```

При запуске должен появиться запрос на ввод:
```sh
`?` for help >
```

Ввод команды заканчивается переводом строки, то есть прежде чем вводить аргумент
команды, нужно нажать *Enter*. Доступны следующие команды:
 - *?* подсказка по командам;
 - *a* добавить путь в индекс, следующей строкой вводится путь;
 - *r* удалить путь из индекса, следующей строкой вводится путь;
 - *c* отменяет последнюю операцию регистрации/дерегистрации, если она все еще выполняется;
 - *s* поиск фалов по слову, следующей строкой вводится слово. Файлы, помеченные
 звездочкой изменены с момента последнего разбора и еще не обработаны;
 - *f* выводит полный список файлов и статистику. Пометки слева от файла: плюс -
 файл обработан, звездочка - в процессе обработки, минус - обработка не удалась;
 - *w* выводит полный список слов;
 - *i* выводит краткую статистику по индексу;
 - *l* последовательно переключает уровень лога, отображаемого в консоль;
 - *q* штатное завершение программы.

## Общие замечания по работе
Библиотека работает стабильно, за несколько минут может управиться с */usr/include* в 44000
файлов. Немного давится бинарными файлами, так как парсер считает их текстовыми. Например,
бинарный файл, размером несколько десятков мегабайт, может на выходе дать более 200000 уникальных
слов, которые больше нигде не встречаются, что отрицательно сказывается на памяти.